/*
* Copyright (c) 2016, Martin Wawro
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
* 1. Redistributions of source code must retain the above copyright notice, this
*    list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright notice,
*    this list of conditions and the following disclaimer in the documentation
*    and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
* ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
* ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*
* The views and conclusions contained in the software and documentation are those
* of the authors and should not be interpreted as representing official policies,
* either expressed or implied, of the FreeBSD Project.
*/
package org.mtnwrw.cameraexample.acquisition;

import android.content.ContentValues;
import android.content.Context;
import android.content.SharedPreferences;
import android.database.sqlite.SQLiteDatabase;
import android.graphics.ImageFormat;
import android.hardware.camera2.DngCreator;
import android.hardware.camera2.TotalCaptureResult;
import android.media.Image;
import android.os.Handler;
import android.os.HandlerThread;
import android.os.Looper;
import android.os.Message;
import android.util.Log;

import org.mtnwrw.cameraexample.db.DatabaseManager;
import org.mtnwrw.pdqimg.CompressionQueueEntry;
import org.mtnwrw.pdqimg.CompressionService;

import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.Buffer;
import java.nio.ByteBuffer;
import java.nio.channels.Channels;
import java.nio.channels.WritableByteChannel;
import java.sql.Timestamp;
import java.util.Stack;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * Handler class for full-frame capture events that are generated by the {@link CameraDriver}.
 *
 * <p>
 * This handler class includes all functionality required to dispatch captured images to the
 * compression queue and write the output of the compression queue to flash storage (and a
 * database for management).
 * </p>
 *
 * @author Martin Wawro
 */
public class SnapshotEventHandler implements SnapshotEventInterface {

  //------------------------------------------------------------------------------------------------
  // Constants
  //------------------------------------------------------------------------------------------------

  private static final String LOGTAG="SnapEvent";
  private static final String PREFS="AcquisitionPreferences";

  /**
   * Message type for compression messages.
   *
   * @see WriteHandler#handleMessage(Message)
   */
  private static final int COMPRESS_IMAGE=0;

  /**
   * Message type for finalization messages.
   *
   * @see WriteHandler#handleMessage(Message)
   */
  private static final int ROLL_DONE=1;


  /**
   * State enumerator which indicates that there is no acquisition currently running.
   *
   * @see #RollState
   */
  private static final int ROLLSTATE_HALTED=0;

  /**
   * State enumerator which indicates that acquisition is in progress.
   *
   * @see #RollState
   */
  private static final int ROLLSTATE_RUNNING=1;

  //------------------------------------------------------------------------------------------------
  // Nested class definitions
  //------------------------------------------------------------------------------------------------


  /**
   * Message to be sent to writer thread.
   *
   * <p>
   * This class is to be used as payload for COMPRESS_IMAGE type messages that are to be sent to
   * the {@link #WriterThread}. They encapsulate a target buffer in conjunction with a unique
   * numerator for the image (serial#).
   * </p>
   *
   * @author Martin Wawro
   */
  class WriterMessage {
    private ByteBuffer Buffer;
    private int SerialNo = 0;
    private int Format;


    /**
     * Constructor
     *
     * @param buffer ByteBuffer which holds the compressed data
     *
     * @param format The image format that was used for the capture
     *
     * @param serialNo The sequence ID of the image within the roll to be written
     */
    public WriterMessage(ByteBuffer buffer, int format, int serialNo) {
      Buffer = buffer;
      Format = format;
      SerialNo = serialNo;
    }

    /**
     *
     */
    void write() {
      String filename = String.format("%08d.iff",SerialNo);
      File outfile = new File(SnapshotEventHandler.this.AppContext.getFilesDir(),filename);
      try {
        //------------------------------------------------------
        // Create output stream and write contents of the output
        // buffer...
        //------------------------------------------------------
        FileOutputStream outstream = new FileOutputStream(outfile);
        WritableByteChannel bytechan = Channels.newChannel(outstream);
        bytechan.write(Buffer);
        outstream.close();
        Buffer.rewind();
      } catch (FileNotFoundException ex) {
        CaptureError="Unable to write output file.";
      } catch (IOException ex) {
        CaptureError="Unable to write output file.";
      } finally {
        //------------------------------------------------------
        // Release the buffer back to the buffer pool...
        //------------------------------------------------------
        SnapshotEventHandler.this.Buffers.push(Buffer);
      }
    }
  }


  /**
   * Single entry of the compression queue.
   *
   * <p>
   * This class derives from {@link CompressionQueueEntry} and expands it with some bookkeeping
   * variables. Objects of this class are then dispatched to the native code that performs the
   * actual compression.
   * </p>
   * @author Martin Wawro
   */
  class QueueEntry extends CompressionQueueEntry {
    private int SerialNo = 0;
    private CameraDriver Camera;
    private int Format;

    /**
     *
     * @param camDriver The CameraDriver instance that delivers the input data for this entry
     *
     * @param tc Capture results from the camera
     *
     * @param img The image acquired by the camera
     *
     * @param outstream The target buffer (output buffer) that will contain the compressed data
     *
     * @param serialNo A serial number for the queue entry (e.g. offset within the current camera
     *                 roll)
     */
    public QueueEntry(CameraDriver camDriver,TotalCaptureResult tc,Image img,ByteBuffer outstream,int serialNo) {
      super(camDriver.getCameraCharacteristics(),tc,img,outstream);
      Camera = camDriver;
      SerialNo = serialNo;
      Format = camDriver.CaptureFormat;
      RawBitDepth = camDriver.getRawBits();
    }

    /**
     * Callback handler invoked when compression of a single image has been completed.
     *
     * <p>
     *
     * Note that this function is invoked from a native "output" thread and while this function
     * blocks, no other output can be triggered. Especially in cases where the images are too
     * large for the storage bandwidth, this may lead to congestion on the output queue.
     * </p>
     *
     * @param error Error indicator, will be set to true if any error occured during the
     *              compression and the image cannot be used.
     *
     */
    public void compressionDone(boolean error) {
      //-----------------------------------------------------
      // Close image and free resources...
      //-----------------------------------------------------
      ImageData.close();
      ImageData = null;
      if (Camera != null) Camera.AvailableBuffers.release();
      //-----------------------------------------------------
      // Send write-message to output queue if there was
      // no error and the output seems to be valid..
      //-----------------------------------------------------
      if ((!error) && (OutputSize>0)) {
        Writer.sendMessage(Message.obtain(Writer, COMPRESS_IMAGE, new WriterMessage(OutputStream, Format, SerialNo)));
      }
      int pending = PendingQueueEntries.decrementAndGet();
      if (pending==0) {
        WaitLock.lock();
        WaitCondition.signalAll();
        WaitLock.unlock();
      }
    }
  }


  /**
   * Background handler for writing images.
   *
   * <p>
   * This handler collects messages which are emerging from the compression-completed callback
   * {@link QueueEntry#compressionDone(boolean)}.
   * It performs the writing of the compressed data and also enters the results of each
   * acquisition session to the database.
   * </p>
   *
   * @author Martin Wawro
   */
  class WriteHandler extends Handler {

    private int FirstSerial=0;
    private int LastSerial=0;
    private int Format = 0;

    /**
     * Constructor
     *
     * @param looper The event loop to connect to
     */
    public WriteHandler(Looper looper) {
      super(looper);
    }

    /**
     * Process single message in message handler thread.
     *
     * @param m The message to process
     */
    @Override
    public void handleMessage(Message m) {
      //-------------------------------------------------------
      // Handle compression messages...
      //-------------------------------------------------------
      if (m.what == COMPRESS_IMAGE) {
        WriterMessage msg = (WriterMessage)m.obj;
        if (msg != null) {
          msg.write();
          if (FirstSerial==0) FirstSerial=msg.SerialNo;
          LastSerial = msg.SerialNo;
          Format = msg.Format;
        }
      } else if (m.what == ROLL_DONE) {
        //-----------------------------------------------------
        // Handle roll-finalization messages...
        //-----------------------------------------------------
        if (LastSerial>0) {
          String fmt = null;
          switch (Format) {
            case ImageFormat.YUV_420_888:
              fmt = "YUV420";
              break;
            case ImageFormat.RAW_SENSOR:
              fmt = "RAW";
              break;
            default:
              break;
          }
          int numimages = LastSerial-FirstSerial+1;
          if ((fmt != null) && (numimages>0)) {
            ContentValues row = new ContentValues();
            SQLiteDatabase db = DatabaseManager.getInstance().getWritableDatabase();
            row.put(DatabaseManager.ROLL_COLUMN_TIMESTAMP, DatabaseManager.timestampToString(RollStart));
            row.put(DatabaseManager.ROLL_COLUMN_NUM_IMAGES, numimages);
            row.put(DatabaseManager.ROLL_COLUMN_FORMAT, fmt);
            row.put(DatabaseManager.ROLL_COLUMN_FIRST_SERIAL, FirstSerial);
            long rowid = db.insert(DatabaseManager.ROLL_TABLE,null,row);
            // TODO (mw) handle errors here
          }
        }
        WaitLock.lock();
        FirstSerial=0;
        LastSerial = 0;
        RollState.compareAndSet(ROLLSTATE_RUNNING,ROLLSTATE_HALTED);
        WaitCondition.signalAll();
        WaitLock.unlock();
      }
    }
  }

  //------------------------------------------------------------------------------------------------
  // Member variables
  //------------------------------------------------------------------------------------------------

  /**
   * The application context that this app is running under.
   */
  protected Context AppContext = null;

  /**
   * The serial number to use for the next image (used to generate filenames for storage)
   */
  protected int NextImageSerial = 1;


  /**
   * Output ByteBuffer instances which may be reused for compression.
   */
  protected Stack<ByteBuffer> Buffers = new Stack<ByteBuffer>();

  /**
   * The quality to be used for the compression. Can either be LOW, MEDIUM or HIGH.
   */
  protected CompressionService.quality Quality = CompressionService.quality.QUALITY_MEDIUM;

  /**
   * Background thread for writing the compressed data to flash storage.
   */
  protected HandlerThread WriterThread;

  /**
   * Handler which performs writing in the background thread.
   */
  protected WriteHandler Writer;

  /**
   * Mutex to be used in conjunction with the {@link #WaitCondition}.
   */
  protected Lock WaitLock = new ReentrantLock();

  /**
   * Wait condition which is used to signal the waiting thread(s) once the pending queue items
   * have been flushed.
   */
  protected Condition WaitCondition = WaitLock.newCondition();

  /**
   * Timestamp when the acquisition of the current/last role was started.
   */
  protected Timestamp RollStart = null;

  /**
   * Counter which keeps track of the number of entries which were successfully pushed to the
   * compression queue.
   */
  protected AtomicInteger PendingQueueEntries = new AtomicInteger(0);

  /**
   * Current state of this instance in terms of acquisition. Can either be {@code ROLLSTATE_HALTED}
   * in case no acquisition session is currently active, or {@code ROLLSTATE_RUNNING} in case an
   * acquisition session is active.
   */
  protected AtomicInteger RollState = new AtomicInteger(ROLLSTATE_HALTED);


  protected String CaptureError = null;

  //------------------------------------------------------------------------------------------------
  // Class implementation
  //------------------------------------------------------------------------------------------------


  /**
   * Constructor.
   *
   * <p>
   * Initializes internal variables from preferences and launches background thread for writing
   * compressed data.
   * </p>
   *
   * @param appContext Application context for the app.
   */
  public SnapshotEventHandler(Context appContext) {
    AppContext = appContext;
    //------------------------------------------------
    // Load preferences and initialize some default
    // values...
    //------------------------------------------------
    SharedPreferences settings = AppContext.getSharedPreferences(PREFS, 0);
    if (settings.contains("Quality")) {
      String quality = settings.getString("Quality","MEDIUM").toUpperCase();
      switch (quality) {
        case "LOW":
          Quality = CompressionService.quality.QUALITY_LOW;
          break;
        case "MEDIUM":
          Quality = CompressionService.quality.QUALITY_MEDIUM;
          break;
        case "HIGH":
          Quality = CompressionService.quality.QUALITY_HIGH;
          break;
      }
    } else {
      Quality = CompressionService.quality.QUALITY_MEDIUM;
    }
    if (settings.contains("NextImageSerial")) {
      NextImageSerial = settings.getInt("NextImageSerial",1);
    }
    //------------------------------------------------
    // Fire-up the writer thread for writing to flash
    // storage...
    //------------------------------------------------
    WriterThread = new HandlerThread("WriterThread");
    WriterThread.start();
    Writer = new WriteHandler(WriterThread.getLooper());
  }


  /**
   * Mark the beginning of an acquisition session.
   *
   * <p>
   * This function must be invoked prior to actually starting the acquisition session. It resets
   * some internal variables and changes the internal state accordingly.
   * </p>
   */
  @Override
  public boolean newRoll() {
    if (RollState.compareAndSet(ROLLSTATE_HALTED,ROLLSTATE_RUNNING)) {
      RollStart = new Timestamp(System.currentTimeMillis());
      CaptureError = null;
      return true;
    }
    return false;
  }


  /**
   * Mark the end of an acquisition session.
   *
   * <p>
   * This function must be invoked once an acquisition session has been completed. It waits for
   * the compression queue to clear and sends a ROLL_DONE message to the writer-thread in order
   * to complete the write-cycle for the compressed images.
   * </p>
   * <p>
   * Please note that this function does <b>not</b> wait for the writer-thread to be finished.
   * See the {@link #waitRoll()} function for that functionality. It is advised to always use
   * the {@link #waitRoll()} function for correct closure of an acquisition session.
   * </p>
   */
  @Override
  public void rollDone() {
    WaitLock.lock();
    while (PendingQueueEntries.get()>0) {
      try {
        WaitCondition.await();
      } catch (InterruptedException ex) {
      }
    }
    WaitLock.unlock();
    Writer.sendEmptyMessage(ROLL_DONE);
  }


  /**
   *
   */
  @Override
  public void waitRoll() {
    WaitLock.lock();
    while (!RollState.compareAndSet(ROLLSTATE_HALTED,ROLLSTATE_HALTED)) {
      try {
        WaitCondition.await();
      } catch (InterruptedException ex) {
      }
    }
    WaitLock.unlock();
  }


  /**
   * Clean up internally-used writing buffers by deallocating them.
   *
   * <p>
   * This function deallocates all output buffers which are maintained by this instance. As
   * output buffers are reused for performance reasons (they are kept in {@link #Buffers}), they
   * are not automatically freed after they have been written and this function must be used to
   * take care of that.
   * </p>
   *
   * <p>
   * Please make sure that <b>no</b> acquisition session is running when invoking this
   * function (see {@link #waitRoll()}). Calling this function while a writer is still
   * running will cause undefined behaviour, including crashes.
   * </p>
   */
  @Override
  public void cleanUp() {
    //----------------------------------------------------------
    // Deallocate memory used up by output buffers...
    //----------------------------------------------------------
    while (!Buffers.isEmpty()) {
      ByteBuffer buf = Buffers.pop();
      CompressionService.closeOutputBuffer(buf);
    }
  }


  /**
   * Completely shut down the event handler.
   *
   * <p>
   * This function shuts down the event handler by stopping the background writer thread. It also
   * deallocates all output buffers which were used by the compressor.
   * </p>
   * <p>
   * Note that the instance should not be actively used for compression after calling this function.
   * </p>
   */
  @Override
  public void shutdown() {
    WriterThread.quitSafely();
    try {
      WriterThread.join();
    } catch (InterruptedException ex) {
      ex.printStackTrace();
    }
    waitRoll();
    cleanUp();    // just to make sure
    savePreferences();
  }


  /**
   * Obtain current compression quality setting for this instance.
   *
   * @return Compression quality
   *
   * @see org.mtnwrw.pdqimg.CompressionService.quality
   */
  @Override
  public CompressionService.quality getQuality() {
    return Quality;
  }


  /**
   * Set compression quality for this instance.
   *
   * @param quality The compression quality to use for the next roll
   *
   * @see org.mtnwrw.pdqimg.CompressionService.quality
   */
  @Override
  public void setQuality(CompressionService.quality quality) {
    Quality = quality;
  }

  /**
   * Save (parts of the) current state to preferences.
   *
   */
  public void savePreferences() {
    SharedPreferences settings = AppContext.getSharedPreferences(PREFS,0);
    SharedPreferences.Editor editor = settings.edit();
    editor.putInt("NextImageSerial",NextImageSerial);
    editor.commit();
  }


  /**
   * Callback which is triggered when a captured image is available.
   *
   * <p>
   * This function is invoked from the {@link CameraDriver} instance everytime an image is available
   * from the camera.
   * </p>
   *
   * @param driver The {@link CameraDriver} instance which caused the invocation of this function
   *
   * @param img Image acquired from the camera
   *
   * @param result The meta-data that match the supplied image
   */
  public void onImageAvailable(CameraDriver driver,Image img, TotalCaptureResult result) {
    if (img != null) {
      if (RollState.get() == ROLLSTATE_RUNNING) {
        //------------------------------------------------------
        // See if we have a buffer we can reuse, if not
        // allocate a new one...
        //------------------------------------------------------
        ByteBuffer outstream;
        int capacity = 0;
        int imgsize = img.getWidth() * img.getHeight();
        if (Buffers.isEmpty()) {
          switch (Quality) {
            case QUALITY_LOW:
              if (driver.CaptureFormat == ImageFormat.RAW_SENSOR) capacity = imgsize / 5;
              else capacity = imgsize / 8;
              break;
            case QUALITY_MEDIUM:
              if (driver.CaptureFormat == ImageFormat.RAW_SENSOR) capacity = imgsize / 2;
              else capacity = imgsize / 4;
              break;
            case QUALITY_HIGH:
              if (driver.CaptureFormat == ImageFormat.RAW_SENSOR) capacity = imgsize;
              else capacity = imgsize / 3;
              break;
          }
          outstream = CompressionService.createOutputBuffer(capacity);
        } else {
          outstream = Buffers.pop();
        }
        //------------------------------------------------------
        // ..and finally push the image to the compression
        // queue...
        //------------------------------------------------------
        QueueEntry ent = new QueueEntry(driver, result, img, outstream, NextImageSerial++);
        if (driver.CaptureFormat == ImageFormat.RAW_SENSOR) ent.setCFAPattern(driver.CFAPattern);
        CompressionService.queuestatus status = CompressionService.addToQueue(ent, Quality);
        //------------------------------------------------------
        // If image was not pushed to the queue successfully,
        // release resources here..
        //------------------------------------------------------
        if (status != CompressionService.queuestatus.QUEUE_OK) {
          img.close();
          driver.AvailableBuffers.release();
          Buffers.push(outstream);
        } else {
          PendingQueueEntries.incrementAndGet();
        }
      } else {
        img.close();
      }
    } // null image
  }

}
